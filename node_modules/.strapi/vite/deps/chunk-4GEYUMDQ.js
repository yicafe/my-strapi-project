import {
  useWebhooks
} from "./chunk-YTHRQWCY.js";
import {
  selectAdminPermissions
} from "./chunk-4MBCKCTI.js";
import {
  BackButton,
  Form2 as Form,
  Layouts,
  MemoizedInputRenderer,
  MemoizedStringInput,
  create4 as create,
  create6 as create2,
  create7 as create3,
  create8 as create4,
  useEnterprise,
  useField,
  useForm
} from "./chunk-WAN4NJHK.js";
import {
  Page,
  useAPIErrorHandler,
  useNotification,
  useTypedSelector
} from "./chunk-Z4DUCMVZ.js";
import {
  Box,
  Button,
  CheckboxImpl,
  Combobox,
  Field,
  Flex,
  Grid,
  IconButton,
  Main,
  Option,
  RawTable,
  RawTbody,
  RawTd,
  RawTh,
  RawThead,
  RawTr,
  TextButton,
  Typography,
  VisuallyHidden,
  isBaseQueryError,
  useIntl
} from "./chunk-3AE57NTV.js";
import {
  useMatch,
  useNavigate
} from "./chunk-ZJMETV45.js";
import {
  ForwardRef$1Z,
  ForwardRef$1d,
  ForwardRef$1f,
  ForwardRef$2f,
  ForwardRef$3$,
  ForwardRef$4x
} from "./chunk-UCO6YWR3.js";
import {
  require_jsx_runtime
} from "./chunk-QBLEIVF7.js";
import {
  dt
} from "./chunk-WRI5LBAT.js";
import {
  require_react
} from "./chunk-BCGHH3YY.js";
import {
  __toESM
} from "./chunk-WGAPYIUP.js";

// node_modules/@strapi/admin/dist/admin/EditPage-qRfveoLn.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var React = __toESM(require_react(), 1);
var EventsRoot = ({ children }) => {
  const { formatMessage } = useIntl();
  const label = formatMessage({
    id: "Settings.webhooks.form.events",
    defaultMessage: "Events"
  });
  return (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", alignItems: "stretch", gap: 1, children: [
    (0, import_jsx_runtime.jsx)(Field.Label, { "aria-hidden": true, children: label }),
    (0, import_jsx_runtime.jsx)(StyledTable, { "aria-label": label, children })
  ] });
};
var StyledTable = dt(RawTable)`
  tbody tr:nth-child(odd) {
    background: ${({ theme }) => theme.colors.neutral100};
  }

  thead th span {
    color: ${({ theme }) => theme.colors.neutral500};
  }

  td,
  th {
    padding-block-start: ${({ theme }) => theme.spaces[3]};
    padding-block-end: ${({ theme }) => theme.spaces[3]};
    width: 6%;
    vertical-align: middle;
  }

  tbody tr td:first-child {
    /**
     * Add padding to the start of the first column to avoid the checkbox appearing
     * too close to the edge of the table
     */
    padding-inline-start: ${({ theme }) => theme.spaces[2]};
  }
`;
var getCEHeaders = () => {
  const headers = [
    { id: "Settings.webhooks.events.create", defaultMessage: "Create" },
    { id: "Settings.webhooks.events.update", defaultMessage: "Update" },
    { id: "app.utils.delete", defaultMessage: "Delete" },
    { id: "app.utils.publish", defaultMessage: "Publish" },
    { id: "app.utils.unpublish", defaultMessage: "Unpublish" }
  ];
  return headers;
};
var EventsHeaders = ({ getHeaders = getCEHeaders }) => {
  const { formatMessage } = useIntl();
  const headers = getHeaders();
  return (0, import_jsx_runtime.jsx)(RawThead, { children: (0, import_jsx_runtime.jsxs)(RawTr, { children: [
    (0, import_jsx_runtime.jsx)(RawTh, { children: (0, import_jsx_runtime.jsx)(VisuallyHidden, { children: formatMessage({
      id: "Settings.webhooks.event.select",
      defaultMessage: "Select event"
    }) }) }),
    headers.map((header) => {
      if (["app.utils.publish", "app.utils.unpublish"].includes((header == null ? void 0 : header.id) ?? "")) {
        return (0, import_jsx_runtime.jsx)(
          RawTh,
          {
            title: formatMessage({
              id: "Settings.webhooks.event.publish-tooltip",
              defaultMessage: "This event only exists for content with draft & publish enabled"
            }),
            children: (0, import_jsx_runtime.jsx)(Typography, { variant: "sigma", textColor: "neutral600", children: formatMessage(header) })
          },
          header.id
        );
      }
      return (0, import_jsx_runtime.jsx)(RawTh, { children: (0, import_jsx_runtime.jsx)(Typography, { variant: "sigma", textColor: "neutral600", children: formatMessage(header) }) }, header.id);
    })
  ] }) });
};
var EventsBody = ({ providedEvents }) => {
  const events = providedEvents || getCEEvents();
  const { value = [], onChange } = useField("events");
  const inputName = "events";
  const inputValue = value;
  const disabledEvents = [];
  const formattedValue = inputValue.reduce((acc, curr) => {
    const key = curr.split(".")[0];
    if (!acc[key]) {
      acc[key] = [];
    }
    acc[key].push(curr);
    return acc;
  }, {});
  const handleSelect = (name, value2) => {
    const set = new Set(inputValue);
    if (value2) {
      set.add(name);
    } else {
      set.delete(name);
    }
    onChange(inputName, Array.from(set));
  };
  const handleSelectAll = (name, value2) => {
    const set = new Set(inputValue);
    if (value2) {
      events[name].forEach((event) => {
        if (!disabledEvents.includes(event)) {
          set.add(event);
        }
      });
    } else {
      events[name].forEach((event) => set.delete(event));
    }
    onChange(inputName, Array.from(set));
  };
  return (0, import_jsx_runtime.jsx)(RawTbody, { children: Object.entries(events).map(([event, value2]) => {
    return (0, import_jsx_runtime.jsx)(
      EventsRow,
      {
        disabledEvents,
        name: event,
        events: value2,
        inputValue: formattedValue[event],
        handleSelect,
        handleSelectAll
      },
      event
    );
  }) });
};
var getCEEvents = () => {
  const entryEvents = [
    "entry.create",
    "entry.update",
    "entry.delete",
    "entry.publish",
    "entry.unpublish"
  ];
  return {
    entry: entryEvents,
    media: ["media.create", "media.update", "media.delete"]
  };
};
var EventsRow = ({
  disabledEvents = [],
  name,
  events = [],
  inputValue = [],
  handleSelect,
  handleSelectAll
}) => {
  const { formatMessage } = useIntl();
  const enabledCheckboxes = events.filter((event) => !disabledEvents.includes(event));
  const hasSomeCheckboxSelected = inputValue.length > 0;
  const areAllCheckboxesSelected = inputValue.length === enabledCheckboxes.length;
  const onChangeAll = () => {
    const valueToSet = !areAllCheckboxesSelected;
    handleSelectAll(name, valueToSet);
  };
  const targetColumns = 5;
  return (0, import_jsx_runtime.jsxs)(RawTr, { children: [
    (0, import_jsx_runtime.jsx)(RawTd, { children: (0, import_jsx_runtime.jsx)(
      CheckboxImpl,
      {
        "aria-label": formatMessage({
          id: "global.select-all-entries",
          defaultMessage: "Select all entries"
        }),
        name,
        checked: hasSomeCheckboxSelected && !areAllCheckboxesSelected ? "indeterminate" : areAllCheckboxesSelected,
        onCheckedChange: onChangeAll,
        children: removeHyphensAndTitleCase(name)
      }
    ) }),
    events.map((event) => {
      return (0, import_jsx_runtime.jsx)(RawTd, { textAlign: "center", children: (0, import_jsx_runtime.jsx)(Flex, { width: "100%", justifyContent: "center", children: (0, import_jsx_runtime.jsx)(
        CheckboxImpl,
        {
          disabled: disabledEvents.includes(event),
          "aria-label": event,
          name: event,
          checked: inputValue.includes(event),
          onCheckedChange: (value) => handleSelect(event, !!value)
        }
      ) }) }, event);
    }),
    events.length < targetColumns && (0, import_jsx_runtime.jsx)(RawTd, { colSpan: targetColumns - events.length })
  ] });
};
var removeHyphensAndTitleCase = (str) => str.replace(/-/g, " ").split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(" ");
var Events = { Root: EventsRoot, Headers: EventsHeaders, Body: EventsBody, Row: EventsRow };
var EventTableCE = () => {
  return (0, import_jsx_runtime.jsxs)(Events.Root, { children: [
    (0, import_jsx_runtime.jsx)(Events.Headers, {}),
    (0, import_jsx_runtime.jsx)(Events.Body, {})
  ] });
};
var AddHeaderButton = dt(TextButton)`
  cursor: pointer;
`;
var HeadersInput = () => {
  const { formatMessage } = useIntl();
  const addFieldRow = useForm("HeadersInput", (state) => state.addFieldRow);
  const removeFieldRow = useForm("HeadersInput", (state) => state.removeFieldRow);
  const setFieldValue = useForm("HeadersInput", (state) => state.onChange);
  const { value = [] } = useField("headers");
  const removeRow = (index) => {
    if (value.length === 1) {
      setFieldValue("headers", [{ key: "", value: "" }]);
    } else {
      removeFieldRow("headers", index);
    }
  };
  return (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", alignItems: "stretch", gap: 1, children: [
    (0, import_jsx_runtime.jsx)(Field.Label, { children: formatMessage({
      id: "Settings.webhooks.form.headers",
      defaultMessage: "Headers"
    }) }),
    (0, import_jsx_runtime.jsxs)(Box, { padding: 8, background: "neutral100", hasRadius: true, children: [
      value.map((val, index) => {
        return (0, import_jsx_runtime.jsxs)(Grid.Root, { gap: 4, padding: 2, children: [
          (0, import_jsx_runtime.jsx)(Grid.Item, { col: 6, direction: "column", alignItems: "stretch", children: (0, import_jsx_runtime.jsx)(
            HeaderCombobox,
            {
              name: `headers.${index}.key`,
              "aria-label": `row ${index + 1} key`,
              label: formatMessage({
                id: "Settings.webhooks.key",
                defaultMessage: "Key"
              })
            }
          ) }),
          (0, import_jsx_runtime.jsx)(Grid.Item, { col: 6, direction: "column", alignItems: "stretch", children: (0, import_jsx_runtime.jsxs)(Flex, { alignItems: "flex-end", gap: 2, children: [
            (0, import_jsx_runtime.jsx)(Box, { style: { flex: 1 }, children: (0, import_jsx_runtime.jsx)(
              MemoizedStringInput,
              {
                name: `headers.${index}.value`,
                "aria-label": `row ${index + 1} value`,
                label: formatMessage({
                  id: "Settings.webhooks.value",
                  defaultMessage: "Value"
                }),
                type: "string"
              }
            ) }),
            (0, import_jsx_runtime.jsx)(
              IconButton,
              {
                width: "4rem",
                height: "4rem",
                onClick: () => removeRow(index),
                color: "primary600",
                label: formatMessage(
                  {
                    id: "Settings.webhooks.headers.remove",
                    defaultMessage: "Remove header row {number}"
                  },
                  { number: index + 1 }
                ),
                type: "button",
                children: (0, import_jsx_runtime.jsx)(ForwardRef$1Z, { width: "0.8rem" })
              }
            )
          ] }) })
        ] }, `${index}-${JSON.stringify(val.key)}`);
      }),
      (0, import_jsx_runtime.jsx)(Box, { paddingTop: 4, children: (0, import_jsx_runtime.jsx)(
        AddHeaderButton,
        {
          type: "button",
          onClick: () => {
            addFieldRow("headers", { key: "", value: "" });
          },
          startIcon: (0, import_jsx_runtime.jsx)(ForwardRef$1d, {}),
          children: formatMessage({
            id: "Settings.webhooks.create.header",
            defaultMessage: "Create new header"
          })
        }
      ) })
    ] })
  ] });
};
var HeaderCombobox = ({ name, label, ...restProps }) => {
  const [options, setOptions] = React.useState([...HTTP_HEADERS]);
  const { value: headers } = useField("headers");
  const field = useField(name);
  React.useEffect(() => {
    const headerOptions = HTTP_HEADERS.filter(
      (key) => !(headers == null ? void 0 : headers.some((header) => header.key !== field.value && header.key === key))
    );
    setOptions(headerOptions);
  }, [headers, field.value]);
  const handleChange = (value) => {
    field.onChange(name, value);
  };
  const handleCreateOption = (value) => {
    setOptions((prev) => [...prev, value]);
    handleChange(value);
  };
  return (0, import_jsx_runtime.jsxs)(Field.Root, { name, error: field.error, children: [
    (0, import_jsx_runtime.jsx)(Field.Label, { children: label }),
    (0, import_jsx_runtime.jsx)(
      Combobox,
      {
        ...restProps,
        onClear: () => handleChange(""),
        onChange: handleChange,
        onCreateOption: handleCreateOption,
        placeholder: "",
        creatable: true,
        value: field.value,
        children: options.map((key) => (0, import_jsx_runtime.jsx)(Option, { value: key, children: key }, key))
      }
    ),
    (0, import_jsx_runtime.jsx)(Field.Error, {})
  ] });
};
var HTTP_HEADERS = [
  "A-IM",
  "Accept",
  "Accept-Charset",
  "Accept-Encoding",
  "Accept-Language",
  "Accept-Datetime",
  "Access-Control-Request-Method",
  "Access-Control-Request-Headers",
  "Authorization",
  "Cache-Control",
  "Connection",
  "Content-Length",
  "Content-Type",
  "Cookie",
  "Date",
  "Expect",
  "Forwarded",
  "From",
  "Host",
  "If-Match",
  "If-Modified-Since",
  "If-None-Match",
  "If-Range",
  "If-Unmodified-Since",
  "Max-Forwards",
  "Origin",
  "Pragma",
  "Proxy-Authorization",
  "Range",
  "Referer",
  "TE",
  "User-Agent",
  "Upgrade",
  "Via",
  "Warning"
];
var TriggerContainer = ({ isPending, onCancel, response }) => {
  const { statusCode, message } = response ?? {};
  const { formatMessage } = useIntl();
  return (0, import_jsx_runtime.jsx)(Box, { background: "neutral0", padding: 5, shadow: "filterShadow", hasRadius: true, children: (0, import_jsx_runtime.jsxs)(Grid.Root, { gap: 4, style: { alignItems: "center" }, children: [
    (0, import_jsx_runtime.jsx)(Grid.Item, { col: 3, direction: "column", alignItems: "stretch", children: (0, import_jsx_runtime.jsx)(Typography, { children: formatMessage({
      id: "Settings.webhooks.trigger.test",
      defaultMessage: "Test-trigger"
    }) }) }),
    (0, import_jsx_runtime.jsx)(Grid.Item, { col: 3, direction: "column", alignItems: "stretch", children: (0, import_jsx_runtime.jsx)(Status, { isPending, statusCode }) }),
    (0, import_jsx_runtime.jsx)(Grid.Item, { col: 6, direction: "column", alignItems: "stretch", children: !isPending ? (0, import_jsx_runtime.jsx)(Message, { statusCode, message }) : (0, import_jsx_runtime.jsx)(Flex, { justifyContent: "flex-end", children: (0, import_jsx_runtime.jsx)("button", { onClick: onCancel, type: "button", children: (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, alignItems: "center", children: [
      (0, import_jsx_runtime.jsx)(Typography, { textColor: "neutral400", children: formatMessage({
        id: "Settings.webhooks.trigger.cancel",
        defaultMessage: "cancel"
      }) }),
      (0, import_jsx_runtime.jsx)(ForwardRef$3$, { fill: "neutral400", height: "1.2rem", width: "1.2rem" })
    ] }) }) }) })
  ] }) });
};
var Status = ({ isPending, statusCode }) => {
  const { formatMessage } = useIntl();
  if (isPending || !statusCode) {
    return (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, alignItems: "center", children: [
      (0, import_jsx_runtime.jsx)(ForwardRef$2f, { height: "1.2rem", width: "1.2rem" }),
      (0, import_jsx_runtime.jsx)(Typography, { children: formatMessage({ id: "Settings.webhooks.trigger.pending", defaultMessage: "pending" }) })
    ] });
  }
  if (statusCode >= 200 && statusCode < 300) {
    return (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, alignItems: "center", children: [
      (0, import_jsx_runtime.jsx)(ForwardRef$4x, { fill: "success700", height: "1.2rem", width: "1.2rem" }),
      (0, import_jsx_runtime.jsx)(Typography, { children: formatMessage({ id: "Settings.webhooks.trigger.success", defaultMessage: "success" }) })
    ] });
  }
  if (statusCode >= 300) {
    return (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, alignItems: "center", children: [
      (0, import_jsx_runtime.jsx)(ForwardRef$3$, { fill: "danger700", height: "1.2rem", width: "1.2rem" }),
      (0, import_jsx_runtime.jsxs)(Typography, { children: [
        formatMessage({ id: "Settings.error", defaultMessage: "error" }),
        " ",
        statusCode
      ] })
    ] });
  }
  return null;
};
var Message = ({ statusCode, message }) => {
  const { formatMessage } = useIntl();
  if (!statusCode) {
    return null;
  }
  if (statusCode >= 200 && statusCode < 300) {
    return (0, import_jsx_runtime.jsx)(Flex, { justifyContent: "flex-end", children: (0, import_jsx_runtime.jsx)(Typography, { textColor: "neutral600", ellipsis: true, children: formatMessage({
      id: "Settings.webhooks.trigger.success.label",
      defaultMessage: "Trigger succeeded"
    }) }) });
  }
  if (statusCode >= 300) {
    return (0, import_jsx_runtime.jsx)(Flex, { justifyContent: "flex-end", children: (0, import_jsx_runtime.jsx)(Flex, { maxWidth: `25rem`, justifyContent: "flex-end", title: message, children: (0, import_jsx_runtime.jsx)(Typography, { ellipsis: true, textColor: "neutral600", children: message }) }) });
  }
  return null;
};
var WebhookForm = ({
  handleSubmit,
  triggerWebhook,
  isCreating,
  isTriggering,
  triggerResponse,
  data
}) => {
  const { formatMessage } = useIntl();
  const [showTriggerResponse, setShowTriggerResponse] = React.useState(false);
  const EventTable = useEnterprise(
    EventTableCE,
    async () => (await import("./EventsTable-DUz7EZyi-JUAAGIST.js")).EventsTableEE
  );
  const mapHeaders = (headers) => {
    if (!Object.keys(headers).length) {
      return [{ key: "", value: "" }];
    }
    return Object.entries(headers).map(([key, value]) => ({ key, value }));
  };
  if (!EventTable) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)(
    Form,
    {
      initialValues: {
        name: (data == null ? void 0 : data.name) || "",
        url: (data == null ? void 0 : data.url) || "",
        headers: mapHeaders((data == null ? void 0 : data.headers) || {}),
        events: (data == null ? void 0 : data.events) || []
      },
      method: isCreating ? "POST" : "PUT",
      onSubmit: handleSubmit,
      validationSchema: makeWebhookValidationSchema({ formatMessage }),
      children: ({ isSubmitting, modified }) => (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
        (0, import_jsx_runtime.jsx)(
          Layouts.Header,
          {
            primaryAction: (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, children: [
              (0, import_jsx_runtime.jsx)(
                Button,
                {
                  onClick: () => {
                    triggerWebhook();
                    setShowTriggerResponse(true);
                  },
                  variant: "tertiary",
                  startIcon: (0, import_jsx_runtime.jsx)(ForwardRef$1f, {}),
                  disabled: isCreating || isTriggering,
                  children: formatMessage({
                    id: "Settings.webhooks.trigger",
                    defaultMessage: "Trigger"
                  })
                }
              ),
              (0, import_jsx_runtime.jsx)(
                Button,
                {
                  startIcon: (0, import_jsx_runtime.jsx)(ForwardRef$4x, {}),
                  type: "submit",
                  disabled: !modified,
                  loading: isSubmitting,
                  children: formatMessage({
                    id: "global.save",
                    defaultMessage: "Save"
                  })
                }
              )
            ] }),
            title: isCreating ? formatMessage({
              id: "Settings.webhooks.create",
              defaultMessage: "Create a webhook"
            }) : data == null ? void 0 : data.name,
            navigationAction: (0, import_jsx_runtime.jsx)(BackButton, { fallback: "../webhooks" })
          }
        ),
        (0, import_jsx_runtime.jsx)(Layouts.Content, { children: (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", alignItems: "stretch", gap: 4, children: [
          showTriggerResponse && (0, import_jsx_runtime.jsx)(
            TriggerContainer,
            {
              isPending: isTriggering,
              response: triggerResponse,
              onCancel: () => setShowTriggerResponse(false)
            }
          ),
          (0, import_jsx_runtime.jsx)(Box, { background: "neutral0", padding: 8, shadow: "filterShadow", hasRadius: true, children: (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", alignItems: "stretch", gap: 6, children: [
            (0, import_jsx_runtime.jsx)(Grid.Root, { gap: 6, children: [
              {
                label: formatMessage({
                  id: "global.name",
                  defaultMessage: "Name"
                }),
                name: "name",
                required: true,
                size: 6,
                type: "string"
              },
              {
                label: formatMessage({
                  id: "Settings.roles.form.input.url",
                  defaultMessage: "Url"
                }),
                name: "url",
                required: true,
                size: 12,
                type: "string"
              }
            ].map(({ size, ...field }) => (0, import_jsx_runtime.jsx)(
              Grid.Item,
              {
                col: size,
                direction: "column",
                alignItems: "stretch",
                children: (0, import_jsx_runtime.jsx)(MemoizedInputRenderer, { ...field })
              },
              field.name
            )) }),
            (0, import_jsx_runtime.jsx)(HeadersInput, {}),
            (0, import_jsx_runtime.jsx)(EventTable, {})
          ] }) })
        ] }) })
      ] })
    }
  );
};
var NAME_REGEX = /(^$)|(^[A-Za-z][_0-9A-Za-z ]*$)/;
var URL_REGEX = /(^$)|((https?:\/\/.*)(d*)\/?(.*))/;
var makeWebhookValidationSchema = ({ formatMessage }) => create2().shape({
  name: create().nullable().required(
    formatMessage({
      id: "Settings.webhooks.validation.name.required",
      defaultMessage: "Name is required"
    })
  ).matches(
    NAME_REGEX,
    formatMessage({
      id: "Settings.webhooks.validation.name.regex",
      defaultMessage: "The name must start with a letter and only contain letters, numbers, spaces and underscores"
    })
  ),
  url: create().nullable().required(
    formatMessage({
      id: "Settings.webhooks.validation.url.required",
      defaultMessage: "Url is required"
    })
  ).matches(
    URL_REGEX,
    formatMessage({
      id: "Settings.webhooks.validation.url.regex",
      defaultMessage: "The value must be a valid Url"
    })
  ),
  headers: create4((array) => {
    const baseSchema = create3();
    if (array.length === 1) {
      const { key, value } = array[0];
      if (!key && !value) {
        return baseSchema;
      }
    }
    return baseSchema.of(
      create2().shape({
        key: create().required(
          formatMessage({
            id: "Settings.webhooks.validation.key",
            defaultMessage: "Key is required"
          })
        ).nullable(),
        value: create().required(
          formatMessage({
            id: "Settings.webhooks.validation.value",
            defaultMessage: "Value is required"
          })
        ).nullable()
      })
    );
  }),
  events: create3()
});
var cleanData = (data) => ({
  ...data,
  headers: data.headers.reduce((acc, { key, value }) => {
    if (key !== "") {
      acc[key] = value;
    }
    return acc;
  }, {})
});
var EditPage = () => {
  const { formatMessage } = useIntl();
  const match = useMatch("/settings/webhooks/:id");
  const id = match == null ? void 0 : match.params.id;
  const isCreating = id === "create";
  const navigate = useNavigate();
  const { toggleNotification } = useNotification();
  const {
    _unstableFormatAPIError: formatAPIError,
    _unstableFormatValidationErrors: formatValidationErrors
  } = useAPIErrorHandler();
  const stableFormatAPIError = React.useCallback(formatAPIError, []);
  const [isTriggering, setIsTriggering] = React.useState(false);
  const [triggerResponse, setTriggerResponse] = React.useState();
  const { isLoading, webhooks, error, createWebhook, updateWebhook, triggerWebhook } = useWebhooks(
    { id },
    {
      skip: isCreating
    }
  );
  React.useEffect(() => {
    if (error) {
      toggleNotification({
        type: "danger",
        message: stableFormatAPIError(error)
      });
    }
  }, [error, toggleNotification, stableFormatAPIError]);
  const handleTriggerWebhook = async () => {
    try {
      setIsTriggering(true);
      const res = await triggerWebhook(id);
      if ("error" in res) {
        toggleNotification({
          type: "danger",
          message: formatAPIError(res.error)
        });
        return;
      }
      setTriggerResponse(res.data);
    } catch {
      toggleNotification({
        type: "danger",
        message: formatMessage({
          id: "notification.error",
          defaultMessage: "An error occurred"
        })
      });
    } finally {
      setIsTriggering(false);
    }
  };
  const handleSubmit = async (data, helpers) => {
    try {
      if (isCreating) {
        const res = await createWebhook(cleanData(data));
        if ("error" in res) {
          if (isBaseQueryError(res.error) && res.error.name === "ValidationError") {
            helpers.setErrors(formatValidationErrors(res.error));
          } else {
            toggleNotification({
              type: "danger",
              message: formatAPIError(res.error)
            });
          }
          return;
        }
        toggleNotification({
          type: "success",
          message: formatMessage({ id: "Settings.webhooks.created" })
        });
        navigate(`../webhooks/${res.data.id}`, { replace: true });
      } else {
        const res = await updateWebhook({ id, ...cleanData(data) });
        if ("error" in res) {
          if (isBaseQueryError(res.error) && res.error.name === "ValidationError") {
            helpers.setErrors(formatValidationErrors(res.error));
          } else {
            toggleNotification({
              type: "danger",
              message: formatAPIError(res.error)
            });
          }
          return;
        }
        toggleNotification({
          type: "success",
          message: formatMessage({ id: "notification.form.success.fields" })
        });
      }
    } catch {
      toggleNotification({
        type: "danger",
        message: formatMessage({
          id: "notification.error",
          defaultMessage: "An error occurred"
        })
      });
    }
  };
  if (isLoading) {
    return (0, import_jsx_runtime.jsx)(Page.Loading, {});
  }
  const [webhook] = webhooks ?? [];
  return (0, import_jsx_runtime.jsxs)(Main, { children: [
    (0, import_jsx_runtime.jsx)(Page.Title, { children: formatMessage(
      { id: "Settings.PageTitle", defaultMessage: "Settings - {name}" },
      {
        name: "Webhooks"
      }
    ) }),
    (0, import_jsx_runtime.jsx)(
      WebhookForm,
      {
        data: webhook,
        handleSubmit,
        triggerWebhook: handleTriggerWebhook,
        isCreating,
        isTriggering,
        triggerResponse
      }
    )
  ] });
};
var ProtectedEditPage = () => {
  var _a;
  const permissions = useTypedSelector(selectAdminPermissions);
  return (0, import_jsx_runtime.jsx)(Page.Protect, { permissions: (_a = permissions.settings) == null ? void 0 : _a.webhooks.update, children: (0, import_jsx_runtime.jsx)(EditPage, {}) });
};
var EditPage$1 = Object.freeze(Object.defineProperty({
  __proto__: null,
  EditPage,
  ProtectedEditPage
}, Symbol.toStringTag, { value: "Module" }));

export {
  Events,
  EditPage,
  EditPage$1
};
//# sourceMappingURL=chunk-4GEYUMDQ.js.map
