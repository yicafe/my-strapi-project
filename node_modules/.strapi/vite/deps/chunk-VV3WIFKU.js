import {
  useCreateWorkflowMutation,
  useDeleteWorkflowMutation,
  useGetWorkflowsQuery,
  useUpdateWorkflowMutation
} from "./chunk-QZI7O47T.js";
import {
  useDragLayer
} from "./chunk-XFNRNHKP.js";
import {
  Layouts
} from "./chunk-WAN4NJHK.js";
import {
  Page,
  useAPIErrorHandler,
  useNotification
} from "./chunk-Z4DUCMVZ.js";
import {
  Box,
  Flex,
  Typography,
  useIntl
} from "./chunk-3AE57NTV.js";
import {
  ForwardRef$4L
} from "./chunk-UCO6YWR3.js";
import {
  require_jsx_runtime
} from "./chunk-QBLEIVF7.js";
import {
  require_react
} from "./chunk-BCGHH3YY.js";
import {
  __toESM
} from "./chunk-WGAPYIUP.js";

// node_modules/@strapi/review-workflows/dist/_chunks/Layout-DNKR5bym.mjs
var React = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var DEFAULT_UNEXPECTED_ERROR_MSG = {
  id: "notification.error",
  defaultMessage: "An error occurred, please try again"
};
var useReviewWorkflows = (params = {}) => {
  const { toggleNotification } = useNotification();
  const { formatMessage } = useIntl();
  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();
  const { skip = false, ...queryParams } = params;
  const { data, isLoading, error } = useGetWorkflowsQuery(
    {
      populate: ["stages", "stageRequiredToPublish"],
      ...queryParams
    },
    {
      skip
    }
  );
  React.useEffect(() => {
    if (error) {
      toggleNotification({
        type: "danger",
        message: formatAPIError(error)
      });
    }
  }, [error, formatAPIError, toggleNotification]);
  const [createWorkflow] = useCreateWorkflowMutation();
  const create = React.useCallback(
    async (data2) => {
      try {
        const res = await createWorkflow({ data: data2 });
        if ("error" in res) {
          toggleNotification({
            type: "danger",
            message: formatAPIError(res.error)
          });
          return res;
        }
        toggleNotification({
          type: "success",
          message: formatMessage({ id: "actions.created", defaultMessage: "Created workflow" })
        });
        return res;
      } catch (err) {
        toggleNotification({
          type: "danger",
          message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
        });
        throw err;
      }
    },
    [createWorkflow, formatAPIError, formatMessage, toggleNotification]
  );
  const [updateWorkflow] = useUpdateWorkflowMutation();
  const update = React.useCallback(
    async (id, data2) => {
      try {
        const res = await updateWorkflow({ id, data: data2 });
        if ("error" in res) {
          toggleNotification({
            type: "danger",
            message: formatAPIError(res.error)
          });
          return res;
        }
        toggleNotification({
          type: "success",
          message: formatMessage({ id: "actions.updated", defaultMessage: "Updated workflow" })
        });
        return res;
      } catch (err) {
        toggleNotification({
          type: "danger",
          message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
        });
        throw err;
      }
    },
    [formatAPIError, formatMessage, toggleNotification, updateWorkflow]
  );
  const [deleteWorkflow] = useDeleteWorkflowMutation();
  const deleteAction = React.useCallback(
    async (id) => {
      try {
        const res = await deleteWorkflow({ id });
        if ("error" in res) {
          toggleNotification({
            type: "danger",
            message: formatAPIError(res.error)
          });
          return;
        }
        toggleNotification({
          type: "success",
          message: formatMessage({ id: "actions.deleted", defaultMessage: "Deleted workflow" })
        });
        return res.data;
      } catch (err) {
        toggleNotification({
          type: "danger",
          message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
        });
        throw err;
      }
    },
    [deleteWorkflow, formatAPIError, formatMessage, toggleNotification]
  );
  const { workflows = [], meta } = data ?? {};
  return {
    // meta contains e.g. the total of all workflows. we can not use
    // the pagination object here, because the list is not paginated.
    meta,
    workflows,
    isLoading,
    error,
    create,
    delete: deleteAction,
    update
  };
};
var DRAG_DROP_TYPES = {
  STAGE: "stage"
};
var StageDragPreview = ({ name }) => {
  return (0, import_jsx_runtime.jsxs)(
    Flex,
    {
      background: "primary100",
      borderStyle: "dashed",
      borderColor: "primary600",
      borderWidth: "1px",
      gap: 3,
      hasRadius: true,
      padding: 3,
      shadow: "tableShadow",
      width: "30rem",
      children: [
        (0, import_jsx_runtime.jsx)(
          Flex,
          {
            alignItems: "center",
            background: "neutral200",
            borderRadius: "50%",
            height: 6,
            justifyContent: "center",
            width: 6,
            children: (0, import_jsx_runtime.jsx)(ForwardRef$4L, { width: "0.8rem", fill: "neutral600" })
          }
        ),
        (0, import_jsx_runtime.jsx)(Typography, { fontWeight: "bold", children: name })
      ]
    }
  );
};
function getStyle(initialOffset, currentOffset, mouseOffset) {
  if (!initialOffset || !currentOffset || !mouseOffset) {
    return { display: "none" };
  }
  const { x, y } = mouseOffset;
  return {
    transform: `translate(${x}px, ${y}px)`
  };
}
var DragLayerRendered = () => {
  const { itemType, isDragging, item, initialOffset, currentOffset, mouseOffset } = useDragLayer(
    (monitor) => ({
      item: monitor.getItem(),
      itemType: monitor.getItemType(),
      initialOffset: monitor.getInitialSourceClientOffset(),
      currentOffset: monitor.getSourceClientOffset(),
      isDragging: monitor.isDragging(),
      mouseOffset: monitor.getClientOffset()
    })
  );
  if (!isDragging || itemType !== DRAG_DROP_TYPES.STAGE) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)(
    Box,
    {
      height: "100%",
      left: 0,
      position: "fixed",
      pointerEvents: "none",
      top: 0,
      zIndex: 100,
      width: "100%",
      children: (0, import_jsx_runtime.jsxs)(Box, { style: getStyle(initialOffset, currentOffset, mouseOffset), children: [
        (0, import_jsx_runtime.jsx)(StageDragPreview, { name: typeof item.item === "string" ? item.item : null }),
        ";"
      ] })
    }
  );
};
var Root = ({ children }) => {
  return (0, import_jsx_runtime.jsx)(Page.Main, { children: (0, import_jsx_runtime.jsx)(Layouts.Content, { children }) });
};
var Header = ({ title, subtitle, navigationAction, primaryAction }) => {
  const { formatMessage } = useIntl();
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    (0, import_jsx_runtime.jsx)(Page.Title, { children: formatMessage(
      { id: "Settings.PageTitle", defaultMessage: "Settings - {name}" },
      {
        name: title
      }
    ) }),
    (0, import_jsx_runtime.jsx)(
      Layouts.BaseHeader,
      {
        navigationAction,
        primaryAction,
        title,
        subtitle
      }
    )
  ] });
};

export {
  useReviewWorkflows,
  DRAG_DROP_TYPES,
  DragLayerRendered,
  Root,
  Header
};
//# sourceMappingURL=chunk-VV3WIFKU.js.map
