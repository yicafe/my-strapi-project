{"version":3,"file":"relations-BtmMFBpM.mjs","sources":["../../admin/src/services/relations.ts","../../admin/src/utils/relations.ts"],"sourcesContent":["import { generateNKeysBetween } from 'fractional-indexing';\n\nimport {\n  RelationResult as RelResult,\n  FindAvailable,\n  FindExisting,\n} from '../../../shared/contracts/relations';\n\nimport { contentManagerApi } from './api';\n\nimport type { Modules } from '@strapi/types';\nimport type { errors } from '@strapi/utils';\n\ninterface RelationResult extends RelResult {\n  __temp_key__: string;\n}\n\ntype GetRelationsResponse =\n  | {\n      results: Array<RelationResult>;\n      pagination: {\n        page: NonNullable<Modules.EntityService.Params.Pagination.PageNotation['page']>;\n        pageSize: NonNullable<Modules.EntityService.Params.Pagination.PageNotation['pageSize']>;\n        pageCount: number;\n        total: number;\n      } | null;\n      error?: never;\n    }\n  | {\n      results?: never;\n      pagination?: never;\n      error: errors.ApplicationError | errors.YupValidationError;\n    };\n\nconst relationsApi = contentManagerApi.injectEndpoints({\n  endpoints: (build) => ({\n    getRelations: build.query<\n      GetRelationsResponse,\n      FindExisting.Params & {\n        params?: FindExisting.Request['query'];\n      }\n    >({\n      query: ({ model, id, targetField, params }) => {\n        return {\n          url: `/content-manager/relations/${model}/${id}/${targetField}`,\n          method: 'GET',\n          config: {\n            params,\n          },\n        };\n      },\n      serializeQueryArgs: (args) => {\n        const { endpointName, queryArgs } = args;\n        return {\n          endpointName,\n          model: queryArgs.model,\n          id: queryArgs.id,\n          targetField: queryArgs.targetField,\n          locale: queryArgs.params?.locale,\n          status: queryArgs.params?.status,\n        };\n      },\n      merge: (currentCache, newItems) => {\n        if (currentCache.pagination && newItems.pagination) {\n          if (currentCache.pagination.page < newItems.pagination.page) {\n            /**\n             * Relations will always have unique IDs, so we can therefore assume\n             * that we only need to push the new items to the cache.\n             *\n             * Push new items at the beginning as latest items are shown first\n             */\n            currentCache.results = [\n              ...prepareTempKeys(newItems.results, currentCache.results),\n              ...currentCache.results,\n            ];\n            currentCache.pagination = newItems.pagination;\n          } else if (newItems.pagination.page === 1) {\n            /**\n             * We're resetting the relations\n             */\n            currentCache.results = prepareTempKeys(newItems.results);\n            currentCache.pagination = newItems.pagination;\n          }\n        }\n      },\n      forceRefetch({ currentArg, previousArg }) {\n        if (!currentArg?.params && !previousArg?.params) {\n          return false;\n        }\n\n        return (\n          currentArg?.params?.page !== previousArg?.params?.page ||\n          currentArg?.params?.pageSize !== previousArg?.params?.pageSize\n        );\n      },\n      transformResponse: (response: FindExisting.Response) => {\n        if ('results' in response && response.results) {\n          return {\n            ...response,\n            results: prepareTempKeys(response.results.toReversed()),\n          };\n        } else {\n          return response;\n        }\n      },\n      providesTags: ['Relations'],\n    }),\n    searchRelations: build.query<\n      FindAvailable.Response,\n      FindAvailable.Params & {\n        params?: FindAvailable.Request['query'];\n      }\n    >({\n      query: ({ model, targetField, params }) => {\n        return {\n          url: `/content-manager/relations/${model}/${targetField}`,\n          method: 'GET',\n          config: {\n            params,\n          },\n        };\n      },\n      serializeQueryArgs: (args) => {\n        const { endpointName, queryArgs } = args;\n        return {\n          endpointName,\n          model: queryArgs.model,\n          targetField: queryArgs.targetField,\n          _q: queryArgs.params?._q,\n          idsToOmit: queryArgs.params?.idsToOmit,\n          idsToInclude: queryArgs.params?.idsToInclude,\n        };\n      },\n      merge: (currentCache, newItems) => {\n        if (currentCache.pagination && newItems.pagination) {\n          if (currentCache.pagination.page < newItems.pagination.page) {\n            /**\n             * Relations will always have unique IDs, so we can therefore assume\n             * that we only need to push the new items to the cache.\n             */\n            const existingIds = currentCache.results.map((item) => item.documentId);\n            const uniqueNewItems = newItems.results.filter(\n              (item) => !existingIds.includes(item.documentId)\n            );\n            currentCache.results.push(...uniqueNewItems);\n            currentCache.pagination = newItems.pagination;\n          } else if (newItems.pagination.page === 1) {\n            /**\n             * We're resetting the relations\n             */\n            currentCache.results = newItems.results;\n            currentCache.pagination = newItems.pagination;\n          }\n        }\n      },\n      forceRefetch({ currentArg, previousArg }) {\n        if (!currentArg?.params && !previousArg?.params) {\n          return false;\n        }\n\n        return (\n          currentArg?.params?.page !== previousArg?.params?.page ||\n          currentArg?.params?.pageSize !== previousArg?.params?.pageSize\n        );\n      },\n      transformResponse: (response: FindAvailable.Response) => {\n        if (response.results) {\n          return {\n            ...response,\n            results: response.results,\n          };\n        } else {\n          return response;\n        }\n      },\n    }),\n  }),\n});\n\n/**\n * @internal\n * @description Adds a `__temp_key__` to each relation item. This gives us\n * a stable identifier regardless of it's ids etc. that we can then use for drag and drop.\n */\nconst prepareTempKeys = (relations: RelResult[], existingRelations: RelationResult[] = []) => {\n  const [firstItem] = existingRelations.slice(0);\n  const keys = generateNKeysBetween(null, firstItem?.__temp_key__ ?? null, relations.length);\n\n  return relations.map((datum, index) => ({\n    ...datum,\n    __temp_key__: keys[index],\n  }));\n};\n\nconst { useGetRelationsQuery, useLazySearchRelationsQuery } = relationsApi;\n\nexport { useGetRelationsQuery, useLazySearchRelationsQuery };\nexport type { RelationResult };\n","import type { MainField } from './attributes';\nimport type { RelationResult } from '../../../shared/contracts/relations';\n\n/**\n * @internal\n * @description Get the label of a relation, the contract has [key: string]: unknown,\n * so we need to check if the mainFieldKey is defined and if the relation has a value\n * under that property. If it does, we then verify it's type of string and return it.\n *\n * We fallback to the documentId.\n */\nconst getRelationLabel = (relation: RelationResult, mainField?: MainField): string => {\n  const label = mainField && relation[mainField.name] ? relation[mainField.name] : null;\n\n  if (typeof label === 'string') {\n    return label;\n  }\n\n  return relation.documentId;\n};\n\nexport { getRelationLabel };\n"],"names":[],"mappings":"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"}